#pragma config(Sensor, S1, ts, sensorEV3_Touch)
#pragma config(Sensor, S2, gs, sensorEV3_Gyro)
#pragma config(Sensor, S3, cs, sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4, ss, sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB, lm, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC, rm, tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define Black 1
#define Blue 2
#define Green 3
#define Yellow 4
#define Red 5
#define White 6
#define Brown 7

//색상, 마침선, 초기속도, 시작Flag, 검정선 체크값, 거리, 타이어 지름 초기선언.
int color, finish_line, speed = 10, start_val = 0, black_cnt = 0, distance = 0, tire_width = 5.6;

//스피드를 입력하면, go 함수가 실행될 때 양쪽 모터를 앞으로 굴려 로봇을 앞으로 이동시킨다.
void go(int s)
{
   setMotorSpeed(lm, s); //왼쪽 모터를 s 속도로 앞으로 이동시킨다.
   setMotorSpeed(rm, s); //오른쪽 모터를 s 속도로 앞으로 이동시킨다.
}

//색상 인지의 불안정성을 줄이기 위해 안정성 코드 추가
int getStableColor()
{
   static int lastDetectedColor = -1; //마지막으로 인지된 색상의 int 코드를 저장한다.
   static int stableColorCounter = 0; //최종적으로 인지할 색상의 int 코드를 저장한다.
   const int DEBOUNCE_THRESHOLD = 400; //색상 인지의 임계값을 설정한다. 값이 높을수록 색을 더 빡빡하게 분류한다.

   int currentColor = getColorName(cs); //현재 센서가 인지한 색상코드를 변수에 저장한다.

   if (currentColor == lastDetectedColor) //현재 색상과 마지막으로 인지한 색상이 일치한다면
   {
      stableColorCounter++; //안정적인 색상으로 리턴될 확률을 높인다.
   }
   else //다르면
   {
      lastDetectedColor = currentColor; //마지막으로 감지된 색상 변수에 지금 새로 인지한 색상을 저장한다.
      stableColorCounter = 1; //안정적인 색상으로 리턴될 확률을 리셋한다.
   }

   if (stableColorCounter >= DEBOUNCE_THRESHOLD) //만약 임계값보다 안정적인 색상으로 리턴될 확률 수치가 높아진다면,
   {
      return currentColor; //해당 색상을 실제 인지할 색상으로 리턴한다.
   }
   return -1; //그런 값이 아니라면, -1을 리턴한다.
}

void goDistance(int speed, float distanceCm) //speed의 속도로 distanceCm 만큼 거리를 이동한다.
{
   float circumference = tire_width * 3.14159;//타이어의 둘레를 구한다.
   float degreesPerCm = 360.0 / circumference;//타이어 1cm 당 필요한 타이어 회전각도를 구한다.
   int targetDegrees = (int)(distanceCm * degreesPerCm);//이동해야 하는 거리와 1cm당 필요한 타이어 회전각도를 곱해서, 실제 굴려야하는 바퀴의 각도를 구한다.

   resetMotorEncoder(lm); //좌측 모터 인코더를 리셋시킨다.
   resetMotorEncoder(rm); //우측 모터 인코더를 리셋시킨다.

   setMotorTarget(lm, targetDegrees, speed); //타겟 각도에 맞춰 좌측 모터를 회전시킨다.
   setMotorTarget(rm, targetDegrees, speed); //타겟 각도에 맞춰 우측 모터를 회전시킨다.

   while(getMotorRunning(lm) || getMotorRunning(rm)) //만약, 모터를 아직 굴려야 한다면?
   {
      sleep(10); //0.01초 휴식후 바로 반복문을 재개한다.
   }

   go(0); //모터를 다 굴렸다면? 멈춤.
}

//turnSpeed의 속도로, targetAngle 각도로, 현재 각도 기준으로 회전시킨다.
void turnToAngle(int turnSpeed, int targetAngle)
{
   int currentAngle = getGyroDegrees(gs); //현재 각도를 가져온다.

   if (targetAngle > currentAngle) { //만약 목표 각도보다 현재 각도가 낮다면,
      
      setMotorSpeed(lm, turnSpeed); //좌측 모터를 앞으로 회전시킨다.
      setMotorSpeed(rm, -turnSpeed); //우측 모터를 뒤로 회전시킨다.
      
      while(getGyroDegrees(gs) < targetAngle - 2) //목표 각도가 현재 각도보다 더 클때까지
      {
         sleep(5); //설정해둔 방향으로 회전시킨다.
      }
   } else if (targetAngle < currentAngle) { //만약 목표 각도가 현재 각도보다 더 작다면
      
      setMotorSpeed(lm, -turnSpeed); //좌측 모터를 뒤로 회전시킨다.
      setMotorSpeed(rm, turnSpeed); //우측 모터를 앞으로 회전시킨다.
      
      while(getGyroDegrees(gs) > targetAngle + 2) //목표 각도가 현재 각도보다 더 작을때 까지
      {
         sleep(5); //설정해둔 방향으로 회전시킨다.
      }
   }

   go(0); //멈춘다.
   sleep(200); // 0.2초 정도 멈춘다.
}

task main()
{
    clearTimer(T1); //타이머 초기화 및 재시작.(타이머는 항상 자동으로 굴러감.)
   while(getTouchValue(ts) == 0){} //터치 센서가 눌리기 전까지 아무것도 발동되지 않게 설정.
   while(getTouchValue(ts) == 1){} //터치 센서가 눌리는 순간 로직 시작되게 구성.
   while(1)
   {
     	long t1Time = time1[T1]; //타이머의 시간을 While 문 돌때마다 타이머에 추가.
      color = getStableColor(); //앞서 선언한 안정적 색상 코드를 추가.
      distance = getUSDistance(ss); //getUSDistance를 통해 앞에 물체와의 거리를 감지.

      go(speed); //앞으로 전진
      if(color != -1) { //만일 안정적 색상이 제공되었다면 (A)
      	if(!start_val && (color != White)) //만약 아직 시작선을 통과하지 않았고, 센서에 감지된 색상이 흰색이 아니라면(B)
      	{
         		finish_line = color; //마지막 선 저장 변수에 인지한 색상 저장.
         		setLEDColor(ledGreen); //LED 색상을 초록색으로 변경.
         		sleep(700); //0.7초간 반복문을 정지.
         		start_val++; //이후, 시작선 밟음 Flag를 True로 변경. 이 이후 이 조건문을 다시 돌지 않음.
         		color = getColorName(cs); //컬러센서로 감지한 값을 색상 값에 남는다.
      	}
      	if(color == finish_line || black_cnt == 10) //만약 마지막선과 현재선의 색상이 동일하거나, 검은선을 10번 지났다면.
      	{
        		go(0); //멈춘다.
         		setLEDColor(ledRed); //LED 색상을 빨간색으로 바꾼다.
         		displayBigTextLine(1, "record = %.2fsec", t1Time/1000); //현재까지 기록된 타이머의 ms를, s 단위로 변환하여 화면에 출력한다.
         		sleep(50000); //50초라는 수치동안 반복문을 멈춰서 실행시간을 찍을 가능성을 만든다.
       			break; //프로그램 실행 종료.
      	}
      	if(color == Black) { //만약 인지 색상이 검정색이면
      			black_cnt++; //검정색 감지 카운트를 1 늘린다.
      			sleep(500); //0.5초간 반복문을 정지시킨다.
      	}
      	if(start_val && distance < 10) { //만일 이미 시작선을 밟았고, 앞 물체와의 거리가 10cm 미만이라면(C-1)
			    goDistance(speed/2, -20); //일반 속도의 절반 속도로 20cm 후진한다.
      			turnToAngle(speed/2, 90); //일반 속도의 절반 속도로 오른쪽으로 90도 회전한다.
      			goDistance(speed/2, black_cnt * 10); //일반 속도의 절반 속도로 검은색 선을 밟은 수 * 10cm 만큼 전진한다.
      			turnToAngle(speed/2, 180); //일반 속도의 절반 속도로 90도 더 회전한다. (따로 초기화를 중간에 안하기 때문에 180도 까지 회전시켜야함.)
      			go(speed); //이후 기본 속도로 전진한다.
      	}
      	else if(start_val && distance < 50) { //C-1 조건에 부합하지 않고, 만일 이미 시작선을 밟았으며 앞 물체와의 거리가 50cm 미만이라면(C-2)
      		playSound(soundBeepBeep); //Beep 소리를 낸다.
      		go(speed/2); //일반 속도의 절반 속도로 계속 전진한다.
      		sleep(500); //0.5초간 반복문을 멈춘다.
      	}
      	else { //C-1 과 C-2 조건에 전부 부합하지 않는다면
      		if(color == Blue) { //만일 감지한 색상이 파란색이라면
      			playSound(soundBeepBeep); //Beep 사운드를 우선 1번 출력한다.(검정색을 못찍었을때 최초 1번을 찍어야 하기에)
      			for(int i = 1; i < black_cnt; i++){ // 이후, 검정색이 2번 이상 출력된 이후부터 1회 마다
      					playSound(soundBeepBeep); //Beep 사운드를 1회 출력한다.
      			}
      			sleep(1000); //모두 종료된 후 1초 간 반복문을 정지시킨다.
      		}
      		if(color == Red) { //만일 감지한 색상이 빨간색이라면
						turnToAngle(speed/2, -90); //기본 속도의 절반 속도로 왼쪽으로 90도 회전시킨다.
   						goDistance(speed/2, 10 * black_cnt); //기본 속도의 절반 속도로 검은색 감지횟수 * 10cm 만큼 전진한다.
   						turnToAngle(speed/2, -180); //기본 속도의 절반 속도로 왼쪽으로 90도 더 회전시킨다.
   						go(speed); //이후 기본 속도로 전진한다.
      		}
      	}
      }
   }
}
